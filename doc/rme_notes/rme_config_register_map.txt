RME Fireface-400 / Fireface-800 register map
============================================

Version: 0.6
Author: Jonathan Woithe
Date: 27 March 2009


Definitions
-----------

CBA = Command Buffer Address
FF800 = Fireface-800
FF400 = Fireface-400

Multi-byte values sent to/from the Fireface are generally little endian.


Device address space location
-----------------------------

While some register addresses are common between the two interfaces, the
absolute addresses of the settings and control differ.  These are defined
relative to the device "command buffer" address:

  FF800: command buffer address (CBA) = 0xfc88f000
  FF400: command buffer address (CBA) = 0x80100500

The location of the configuration (settings) registers relative to the
command buffer is consistent across devices:

  conf reg 1 address = command buffer address + 5*4

For a FF800 this equates to 0xfc88f014.


Controlling sample rate (DDS)
-----------------------------

Sample rate is controlled by writing the desired sample rate in Hz to the
sample rate control register located at offset 0 from the command buffer
address (0xfc88f000 on a FF800).  Rates which have been observed are 32k,
44.056k, 44.144k, 44.1k, 45.937k, 46.080k, 47.952k, 48k and 48.048k, along
with corresponding 2x and 4x rates.

Nowhere is there any evidence of register 0xfc88f000 being read by the PC. 
It seems that the PC explicitly sets the device to its desired sample rate
and then caches the sample rate locally.

In terms of multipliers the RME treats sample rates greater than 112000 Hz
as 4x rates, with rates greater than 56000 Hz as 2x rates.  Rates less than
30000 Hz and greater than 210000 Hz are invalid.


Configuration registers 1, 2 and 3
----------------------------------

Most RME device configuration is done using configuration registers 1, 2
and 3.  For the ff800 these are:

  config1 = configuration register 1 (FF800: 0xfc88f014, FF400: 0x80100514)
  config2 = configuration register 2 (FF800: 0xfc88f018, FF400: 0x80100518)
  config3 = configuration register 3 (FF800: 0xfc88f01c, FF400: 0x8010051c)

In essence the configuration registers start at CBA+5*4 for both interfaces.

When making a configuration change these registers are always written in a
block of 12 bytes starting at 0xfc88f014 with a block write operation.

Configuration register 1 (FF800: 0xfc88f014, FF400: 0x8010014):

  bits 31-18: unknown, set to 0
  bits 17-16: Phones level:
    00 = +4 dBu
    01 = -10 dBV
    10 = hi-gain
  bits 15-14: unknown, set to 0
  bits 13-11: Output level control (part 1 of 2: FPGA LED drive):
    001 = hi-gain
    010 = +4dBU
    100 = -10dBV
  bit 10: Instrument option: Drive (part 1 of 2: FPGA LED drive) (active = 1)
  bit 9: unknown, set to 0
  bit 8: Phantom power, mic 10 (active = 1)
  bit 7: Phantom power, mic 8 (active = 1)
  bit 6: unknown, set to 0
  bits 5-3: Input level control (part 1 of 2: FPGA LED drive):
    001 = lo-gain
    010 = +4dBU
    100 = -10dbV
  bit 2: Instrument option: speaker emulation (part 1 of 2: FPGA LED drive)
    (active = 1)
  bit 1: Phantom power, mic 9 (active = 1)
  bit 0: Phantom power, mic 7 (active = 1)

Configuration register 2 (FF800: 0xfc88f018, FF400: 0x80100518):

  bits 31-12: unknown, set to 0
  bit 11: Input #1 front switch (active = 1)
  bit 10: unknown, set to 0
  bit 9: Instrument option: Drive (part 2 of 2: CPLD function) (active = 0)
  bit 8: Input #8 rear switch (active = 1)
  bit 7: Input #8 front switch (active = 1)
  bit 6: Input #7 rear switch (active = 1)
  bit 5: Input #7 front switch (active = 1)
  bits 4-3: Output level control (part 2 of 2: CPLD function):
    00 = undefined
    01 = -10dBV
    10 = hi-gain
    11 = +4dBU
  bit 2: Input #1 rear switch (active = 1)
  bits 1-0: Input level control (part 2 of 2: CPLD function):
    00 = lo-gain
    01 = undefined
    10 = +4dBU
    11 = -10dbV

Configuration register 3 (FF800: 0xfc88f01c, FF400: 0x8010051c):
  bit 31: "Drop and stop": always set to 1
  bit 30: Unit option: TMS (active = 1)
  bits 29-27: set to 0
  bit 26: set to 1 for FF400, 0 for FF800
  bits 25-17: set to 0
  bit 16: P12DB_AN0 (normally set to 0)
  bit 15: set to 0
  bit 14: Toggle TCO (normally set to 0)
  bit 13: Word clock single speed: 0 = off, 1 = on
  bits 12-10: Sync reference source:
    000 = ADAT1
    001 = ADAT2
    011 = SPDIF
    100 = Word clock
    101 = TCO
  bit 9: SPDIF input source: 0 = coax, 1 = ADAT2 port
  bit 8: SPDIF output option: ADAT2
  bit 7: SPDIF output option: non-audio
  bit 6: SPDIF output option: emphasis
  bit 5: SPDIF output option: professional
  bit 4: QS control (set to 1)
  bit 3: DS control (set to 1)
  bit 2: Freq1 control (set to 1)
  bit 1: Freq0 control (set to 1)
  bit 0: Clock mode: 0 = Master, 1 = Autosync


Interfacing to device flash
---------------------------

To preserve the device's settings across power cycles the settings are
stored in a flash memory on the device.  This is read during driver
initialisation to ensure the driver's status agrees with that of the device.

There are several classes of things stored in flash: operational settings,
volumes (ie: the mixer status) and configuration/firmware.  Device settings
start at address 0x3000f0000 on the FF800 and 0x00060000 on the FF400.

Mixer (volume) data starts at 0x3000e0000 on the FF800 and 0x00060000 on the
FF400.  Mixer volumes are written in 64-quadlet (256-byte) blocks, one per
hardware channel.  There are 28 hardware channels for the FF800 and 18 for
the FF400.

There are several control groups in the mixer:
  0xe0000 (FF800): "mixer shadow", FF800 only, meaning unclear
  0xe2000 (FF800) / 0x70000 (FF400), 0x0800 bytes: 16-bit volume array
  0xe2800 (FF800) / 0x70800 (FF400), 0x0800 bytes: 16-bit pan array
  0xe3000 (FF800) / 0x71000 (FF400), 0x0040 bytes: 16-bit "vol3" array + 
    "enable MIDI" + "submix" + zero padding to 64 bytes
The third row are the "hardware output volumes".

The meaning of the "mixer shadow" section of the mixer flash is not
understood at present.


Reading the flash

For the FF800 the entire buffer is read directly from flash as a single block.
Polling for "device not busy" should commence after a wait of 5 ms.

For the FF400, the buffer is read in 32-quadlet sub-blocks.  A partial block
is read at the end if the total buffer size is not a multiple of
32-quadlets.  To read a sub-block, the address is placed in register
0x80100288 and the sub-block size (in bytes) in 0x8010028c.  A 0x02 is
then written to CBA+(8*4) to initiate the read.  Polling for "device not
busy" should commence after a wait of 2 ms.


Writing the flash

For the FF800, the entire buffer is written to flash as a single block.
Polling for "device not busy" should commence after a wait of 5 ms.

For the FF400, the buffer is written in 32-quadlet (128-byte) sub-blocks via
a bounce buffer.  If the final sub-block is not 32-quadlets the write is only
as big as the sub-block (that is, no padding takes place).  The sub-block
data to be written is sent to register 0x80100290.  The 2-quadlet register
at 0x80100288 is set with the flash address to write the block to and the
size (in bytes) of the data block.  Finally, a 0x1 is written to CBA+(8*4)
to initiate the write.  Polling for "device not busy" should commence after
a wait of 2 ms.


Erasing the flash

The flash is divided into sections and it is possible to erase each section
separately.  Therefore one only has to erase section of interest when
changing something.

On the FF400, erasure is controlled by writing a special magic number to
the the flash erase control register (CBA+8*4):
  Erase volume: write 0xe
  Erase settings: write 0xd
  Erase configuration (firmware): write 0xc

On the FF800, erasing is controlled by writing 0 to the applicable register:
  Erase volume: register is 0x3fffffff4
  Erase settings: register is 0x3fffffff0
  Erase firmware: register is 0x3fffffff8
  Erase configuration: register is 0x3fffffffc

It's not clear what the distinction between "configuration" and "firmware"
is.  The FF400 appears to only support "configuration" but treats this as
"firmware".  The FF800 supports both as distinct options.

After issuing the erase command one should wait for 500 ms before polling
the device for the "not busy" status.


Waiting for flash

When interacting with the device's flash memory one must wait for the
completion of an operation before attempting another.  The location of the
"device busy" flag differs between the FF400 and FF800.

On the FF800 is part of the quadlet register at 0x801c0004 (part of the
read-only status register block beginning at 0x801c0000).  The device is
ready to accept another command when bit 30 is set.

On the FF400 the wait state is found by reading a quadlet from CBA+8*4.
If this quadlet is zero the FF400 is ready to accept another command.

Most device flash operations have a minimum time to complete.  There's no
point in polling the device busy flag until at least this much time has
elapsed.


Device settings format
----------------------

The device settings are stored in flash as an array of 32 bit unsigned
integers.  These are:
  - Device ID
  - Device revision
  - ASIO latency
  - Samples per frame
  SPDIF input mode (0=coax?, 1=optical?)
  SPDIF output emphasis active
  SPDIF output is "professional" (ie: AES/EBU)
  Clock mode (0=master?, 1=autosync?)
  SPDIF output is non-audio (eg: AC3 passthrough)
  Sync reference
  SPDIF output mode (0=coax?, 1=optical?)
  - Check input
  - Status
  - Register[4]
  - Iso receive channel
  - Iso transmit channel
  - Timecode
  - Number of devices
  - TMS
  - Speed
  - Channels available (high)
  - Channels available (low)
  Limit bandwidth setting
  - Bandwidth allocated
  - Stop on dropout
  Input level 
  Output level
  Mic level [0] - FF400:Phoneslevel-1 / F800:AnalogInput[1]* ???
  Mic level [1] - AnalogInput[2] ???
  Mic phantom power [4]
  Instrument - AnalogInput[0]-1 ???
  Filter (aka speaker emulation)
  Fuzz (aka drive)
  Sync align
  - Device index
  - Advanced dialog
  Sample rate
  - Interleaved
  - Sn
  Word clock single speed
  - Number of channels
  - Dropped samples
  p12db_an[0] - Limiter==0&&AnalogInput[0]==2*: 1 else 0 ???
  - p12db_an[1-9]

"-" = elements not used


Streaming control registers
---------------------------

There appears to be a number of registers involved in the setup of device
streaming.

Device (streaming) initialisation register (FF800: 0x20000001c, FF400: CBA)

This register comprises the 3 quadlets starting at address 0x20000001c on
the FF800 and the CBA on the FF400.  The first quadlet contains the sample
rate in Hz.  The second quadlet is mapped as follows:
  bits 31-11 = number of audio channels
  bits 10-0  = iso tx channel (PC to interface)
In all local tests with a FF800 the value of this quadlet was always equal
to 0x0000e000 (28 channels, PC transmits on iso channel 0).

The third quadlet is mapped as follows.
  bits 10-0 = number of audio channels
  bit 11    = speed flag; set to 1 if firewire bus is at 800 Mbps
In local tests with a FF800 the value of this register was always 0x0000001c
(28 channels, 400 Mbps firewire bus).

After this register is configured, 4 quadlets are read starting from
0x801c0000.  The numbers returned don't appear to bear any relationship to
those written to this same location later on.

Device (streaming) start register (FF800: 0x200000028, FF400: CBA+0x1c):

The start of streaming differs between the FF400 and FF800 in more than just
the address of the relevant register.  On the FF800 this register is mapped
as follows:
  bits 10-0 = number of audio channels
  bit 11    = bus speed flag; set to 1 if firewire bus is at 800 Mbps
On a FF400 the register is as follows:
  bits 4-0  = number of audio channels
  bits 9-5  = iso tx channel (PC to interface)
During initial testing with a FF800 the value of this register was always 
0x0000001c (28 audio channels, PC tx on iso channel 0).

Channel mute setup register (write to 0x801c0000):

After writing to the streaming start register, 0x70 bytes (28 quadlets) are
written starting at 0x801c0000.  Each quadlet represents one channel on the
Fireface800.  A value of 1 mutes the respective channel - indeed on closing
down streaming each quadlet is set to 1.  During startup some values are set
to zero - the ones set to zero may be determined by the channels which have
active software data sources although this is yet to be confirmed with more
testing.  Irrespective of the setting of these registers it appears that
data for all channels is always sent to/from the Fireface-800.

Note that when register 0x801c0000 is read it functions as the device status
register.  It is read during streaming setup, but obviously it bears no
relationship to the channel mute status.

Streaming end register (FF800: 0x200000034, FF400: CBA+0x4):

On the FF800, streaming is stopped by writing 3 zeroed quadlets to
consecutive registers starting at address 0x200000034.  For the FF400 one
writes 3 zeroed quadlets to consecutive registers from CBA+0x4, followed
by a 0x00000001 to CBA+0x10 (making a 4-quadlet write in total).


Iso data
--------

Audio/midi data is sent and received on isochronous channels previously
configured by the driver.  On a dedicated bus with nothing else present, the
stream to the fireface is sent on iso channel 0 while data from the fireface
is sent on iso channel 1.

No CIP header is included in the iso data packet.  Fireface data follows
immediately after the standard 2-quadlet firewire iso packet header.

Each iso packet contains a number of samples across all 28 device channels.
For 1x rates, 7 samples per channel seem to be sent.  Thus the size of 
the data portion of a 1x iso packet is 28*4*7 = 784, with a total packet
size being 784 + 8 = 792.

The data is sent with one audio channel per quadlet.  The audio data is a 24
bit integer stored in the most-significant 3 bytes of a quadlet.  The LSB
(low byte) of certain channels in the stream sent by the Fireface is used to
send synchronising information:

  Low byte of channel 6 = current frame
  Low byte of channel 7 = phase
  Low byte of channel 1 = rx sample counter, low byte
  Low byte of channel 4 = rx sample counter, high byte
  Low byte of channel 0 = tx buffer size, low byte
  Low byte of channel 5 = tx buffer size, high byte
  Low byte of channel 2 & 3 = unknown (midi?)

The low byte data from channels 0-7 is repeated in channels 8-15 and 16-23
respectively, with channels 24-27 containing the low byte data from channels
0-3.  This repetition holds for the low bytes of channels 2-3 in all data
seen so far, it might not necessarily be the case in general - it depends
what the low byte data from channels 2 and 3 are used for.

The rx sample counter appears to be used to detect missed samples.  The
current frame and phase from a received packet is used in conjunction with
the stored values of these from the previous frame to track the phase of
the audio clock.

A "frame" consists of a fixed number of samples across all channels of the
device.  At 1x rates this appears to be 7, but it might not be fixed.  Even
though this is the same as the number of samples per channel per packet, a
given packet can experience a change in the "current frame" part way
through.  In other words, the "current frame" is not necessarily constant
for all samples in a packet.


Mixer controls
--------------

The matrix mixer on the Fireface-800 is controlled using a block of
registers starting at 0x80080000.  A 28x28 matrix mixer is implemented
allowing any device input to be sent to any device output.  The pan controls
are synthesised by manipulating the "left/right" controls.

In each sub-block, the order of channels is in fireface numeric order.  That
is, Analog 1-10, SPDIF, ADAT1 1-8, ADAT2 1-8.

0x80080000 - 0x8008006c: input channel sends to Analog 1 output.
0x80080080 - 0x800800ec: playback channel sends to Analog 1 output.
0x80080100 - 0x8008016c: input channel sends to Analog 2 output.
0x80080180 - 0x800801ec: playback channel sends to Analog 2 output.
:
0x80081b00 - 0x80081b6c: input channel sends to ADAT2-8 output.
0x80081b80 - 0x80081bec: playback channel sends to ADAT2-8 output.

0x80081f80: matrix mixer analog 1 output fader
0x80081f84: matrix mixer analog 2 output fader
:
0x80081fec: maxtrix mixer ADAT2-8 output fader

Each fader control ranges from 0x00000000 (-inf) through 0x00008000 (0.0dB)
and up to a maximum setting of 0x00010000 (+6.5dB).

Mute is synthesised by setting the respective send value to -inf (0). 
Conversely, solo is synthesised by muting all sends to the selected bus
except the send being soloed.


Metering values
---------------

The Fireface-800 appears to provide hardware support for metering.  The RME
mixer application periodically sends block read requests for register
0x80100000 with a size of 0x3f8.  What is returned is a set of two
datablocks with data in little-endian (least significant bit/word first)
format.  The first block contains arrays of 64-bit floating point numbers
representing channel amplitude with decay, presumedly useful for metering
display.  Arrays are:

  28-element array for input channel amplitude with decay
  28-element array for playback amplitudes with decay (educated guess)
  28-element array for output amplitudes with decay

The second data block contains signed 32 bit integers representing the input
amplitudes without decay.  Valid range is 0 - 0x7ffffff.  Again there are 3
arrays:

  28-element array for input channel ampltude
  28-element array for playback amplitudes (educated guess)
  28-element array for output amplitudes

At the end of this second block are two zero quadlets.  Their purpose is
unknown at this stage.

In each 28-element array the channel data appears in standard fireface
order.


Host LED
--------

The "host" LED of the FF800 is controlled by a dedicated register at
0x200000324.  Note that this register address goes beyond the 32-bit
boundary.
